# `/data_structure/stl/`

## Stack-Allocated and Heap-Allocated Memory

### Stack-Allocated Memory: Must be Static

在栈中分配的变量是局部变量，在函数体内存在在对应的栈帧中，
函数体结束变量随栈帧的`pop`随之消失.

栈帧分配的大小需要由编译器预先确定，所以栈中分配的内存大小必须是
静态的(预先确定的常量表达式).

### Heap-Allocated Memory: Dynamic by Nature

栈中的内存可动态分配(`malloc`, `new`), 同时需要程序员在使用完变量后
主动释放(`free`, `delete`). 

栈中的内存生命周期与函数体无关，不会被自动收回. 

由于栈中的内存是动态分配的，系统需要在程序运行时寻找合适的内存块
用于分配，相比栈中预先分配的方式效率较低.

### alloca()

实际上使用`alloca()`函数(继承自C)运行程序在栈上分配内存，函数结束后内存被程序自动回收.
然而由于栈空间较小，容易造成`stack overflow`; 编译器也无法优化; 由于不是`C++ standard`
不具有可移植性.

## template

为了让`Array`可以使用非常量(变量)静态分配内存空间，我们需要借助`template`.

### 实现原理

使用`template`的函数或类作为一个基本蓝图，在实际编译时，编译器根据对应的类型或数值替换
函数或类的对应位置.

由于泛型模板`template`对应的类型或数值需要在编译阶段确定，所以实现泛型的代码一般就在
头文件中，而不是额外的一个源文件. (这里用`.inl`存储实现，在头文件的最后`include`进去)

通过泛型编程，`Array`需要分配的内存可以在编译时确定(静态分配)，例如对于`int`类型大小为`10`
的对象，可以认为编译器单独创建了一个类为`ArrayInt10`的对象.

## this pointer

`this`在`C++`中是一个特殊指针, 是在类内部允许方法引用该类的实例对象的指针.

`this`指针的存在使得对象可以访问自身成员.

`this`指针自动传给非静态成员函数，但在静态成员函数`static member function`
中不可访问，因为静态函数不和类的任意特定实例有关.

`this`指针存储当前对象的起始地址，编译器将其隐式传递给非静态成员变量(一个额外的参数).


